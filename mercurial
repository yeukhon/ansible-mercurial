#!/usr/bin/python

import os
import shutil
from subprocess import Popen, PIPE
#import traceback

DOCUMENTATION = '''
---
module: mercurial
short_description: Manages Mercurial (hg) repositories
description:
  - Manages Mercurial (hg) repositories. Supports SSH, HTTP/S and local operation. To access private repositories, see the Notes section below.
version_added: "1.0"
options:
  repo:
      description:
            - The repository location on disk or on remote service such as Bitbucket.
      required: true
      default: null
  dest:
      description:
            - Absolute path of where the repository should be on disk.
      required: true
      default: null
  state:
      description:
            - State of the repository
      required: false
      default: present
      choices: [ "present", "absent", "latest" ]
author: Yeukhon Wong
notes:
  - To access private repositories using SSH, you can include `StrictHostKeyChecking no` in .ssh/config so it accepts the ssh authentication the first time it connects to an unknown host. 
examples:
- code: "mercurial: repo=https://bitbucket.org/user/repo_name dest=/home/user/repo_name"
  description: Clone the default branch of repo_name.
- code: "mercurial: repo=https://bitbucket.org/user/repo_name dest=/home/user/repo_name state=latest rev="72f75ae"
  description: Clone the repository where the tip is set to revision 72f75ae.
- code: "mercurial: repo=https://bitbucket.org/user/repo_name dest=/home/user/repo_name state=present rev="72f75ae"
  description: Ensure the repository is cloned to disk and revision 72f75ae is the tip of the respoistory.
- code: "mercurial: repo=https://bitbucket.org/user/repo_name dest=/home/user/repo_name state=absent"
  description: Ensure the repository at dest is removed from the disk.
'''

class HgError(Exception):
    """  Custom exception class to report hg command error. """
    def __init__(self, msg, stderr=''):
        self.msg = msg + \
                  "\nExtra information on this error: \n" + \
                   stderr
    def __str__(self):
        return self.msg

def _hg_command(args_list):
    cmd = ['hg'] + args_list
    p = Popen(cmd, stdout=PIPE, stderr=PIPE)
    out, err = p.communicate()
    return out, err, p.returncode

def _hg_verify(dest):
    error1 = "hg verify failed."
    error2 = "{dest} is not a repository.".format(dest=dest)
    out, err, code = _hg_command(['verify', '-R', dest])
    if code == 1:
        raise HgError(error1, stderr=err)
    elif code == 255:
        raise HgError(error2, stderr=err)
    elif code == 0:
        return True

def _post_op_hg_rev_check(dest, rev):
    """
    Verify the tip is the same as `rev`.

    This function is usually called after some hg operations
    such as `clone`. However, this check is skipped if `rev`
    is the string `default` since it will result an error. 
    For this particular case, pull is performed.

    """

    err1 = "Unable to perform hg tip."
    err2 = "tip is different from %s. See below for extended summary." % rev

    if rev == 'default':
        out, err, code = _hg_command(['pull', '-R', dest])
        if "no changes found" in out:
            return True
        else:
            raise HgError(err2, stderr=out)
    else:
        out, err, code = _hg_command(['tip', '-R', dest])
        if rev in out:   # rev should be part of the output (changeset: rev ...)
            return True
        else:
            if code != 0: # something went wrong with hg tip
                raise HgError(err1, stderr=err)
            else: # hg tip is fine, but tip != rev as we hoped
                raise HgError(err2, stderr=out)

def pull_and_update(repo, dest, rev):
    if _hg_verify(dest):
        cmd1 = ['pull', '-R', dest, '-r', rev]
        out, err, code = _hg_command(cmd1)

        if code == 1:
            raise HgError("Unable to perform pull on %s" % dest, stderr=err)
        elif code == 0:        
            cmd2 = ['update', '-R', dest, '-r', rev]
            out, err, code = _hg_command(cmd2)
            if code == 1:
                raise HgError("There are unresolved files in %s" % dest, stderr=err)
            elif code == 0:
                # so far pull and update seems to be working, check rev is met
                _post_op_hg_rev_check(dest, rev)
                return True
        # when code aren't 1 or 0 in either command
        raise HgError("", stderr=err)

def clone(repo, dest, rev):
    if os.path.exists(dest):
        if _hg_verify(dest):  # make sure it's a real repo
            if _post_op_hg_rev_check(dest, rev): # make sure rev is met
                return False

    cmd = ['clone', repo, dest, '-r', rev]
    out, err, code = _hg_command(cmd)
    if code == 0:
        _hg_verify(dest)
        _post_op_hg_rev_check(dest, rev)
        return True
    else:
        raise HgError(err, stderr='')

def main():
    module = AnsibleModule(
        argument_spec = dict(
            repo = dict(required=True),	    
            dest = dict(required=True),
            state = dict(default='present', choices=['present', 'absent', 'latest']),
            rev = dict(default="default"),
        ),
    )
    repo = module.params['repo']
    state = module.params['state']
    dest = module.params['dest']
    rev = module.params['rev']

    try:
        if state == 'absent':
            if not os.path.exists(dest):
                shutil.rmtree(dest)
            changed = True
        elif state == 'present':
            changed = clone(repo, dest, rev)
        elif state == 'latest':
            changed = pull_and_update(repo, dest, rev)

        module.exit_json(dest=dest, changed=changed)
    except HgError as e:
        module.fail_json(msg=str(e), params=module.params)

# include magic from lib/ansible/module_common.py
#<<INCLUDE_ANSIBLE_MODULE_COMMON>>
main()
